<!DOCTYPE html>
<html><head><meta name="viewport" content="width=100" charset="utf-8" >
<script src="/gif.js/gif.js"></script>
<style>html, body {margin: 0;padding: 0;justify-content: center;}canvas {display: block;}</style>
<title>Live View</title>
<body style="background-color:#333333;" >
<canvas id="liveCanvas"  width="5" height="5" style="width: 5px; height: 5px; position: absolute; top: 100px; left: 0px; right: 0px;  margin: auto;"></canvas>
<script>


host="http://<your wled ip>";
url = host+"/json/live";  // live strip state json format 

var windowWidth = 500;
var windowHeight = 500;
var lightSize = 10; // light box size
var lines=0;
var multipartSize=120;  //refer to wled21_liveview multipartSize global variable. (it has to be the same value)
var lightPerLines=1;
var numLights = 0; 
var canvas ;  
ctx  =null;
var m=-1;
var mi=-1;
var mpi=0;

prev_leds = (["#000000"]);  //previous strip state



var record=false;
var fxCount=83;
var fx=0;
gif = null;
gifDuration=20000;
quality=10; //gif quality [1-30] (1 is better)
gifTimeRemaining=gifDuration;
prev_mi=0;

function pcm_loadJSON(url,cbk,cbkError){
    var httpReq = new XMLHttpRequest(); 
    httpReq.overrideMimeType("application/json");
    httpReq.addEventListener("error", cbkError, false);
    httpReq.open("GET",url,true);
    httpReq.responseType="json";
    httpReq.onload=function(e) {
      var json= httpReq.response;
      cbk(json);
    }
    httpReq.onerror=function(e) {
     cbkError(httpReq.error);
    }
    httpReq.send();   
}


function pcm_resizeCanvas(noRedraw){
  if (!noRedraw) {
   pcm_clearCanvas(canvas);
  }
  lightsPerLine = Math.floor(windowWidth / lightSize ); 
  lines = Math.ceil(numLights / lightsPerLine)
  if (lines == 0) {
    lines=1;
  }  
  w = lightsPerLine*lightSize+1;
  h = lines*lightSize+1;
  canvas.width=w;
  canvas.height=h;
  canvas.style.width=w+"px";
  canvas.style.height=h+"px";
}


function pcm_clearCanvas(cnv) {
 ctx.clearRect(0,0,cnv.width,cnv.height);
  for (i = 0; i < numLights ; i++) {
       renderLight(i, "",true);
  }
}

function isOdd(n) {
  if (Math.floor(n/2)*2 != n) return true;
  return false;
}

function renderLight(light, col, stroke) {
  line=Math.floor(light / lightsPerLine);
    if (isOdd(line)){
      reverse=lightsPerLine*lightSize-lightSize;
      drawDirection=-1;
    } else {
    reverse=0;
    drawDirection=1;
  }
  x = reverse+drawDirection*((light % lightsPerLine) * lightSize+0.5*drawDirection);
  y = line * lightSize+0.5;
  if (!stroke){
    ctx.fillStyle = col; 
    ctx.fillRect(x+0.5, y+0.5, lightSize-1, lightSize-1); //create the square representing the light (left, top, width, height)
  } else {
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, lightSize, lightSize); //create the stroke (left, top, width, height)
  }
}

function errorDrawLights(err){
  pcm_loadJSON(url,drawLights,errorDrawLights); //get actual strip state AGAIN
  //console.log("frame reloaded");
}

function drawLights(strip) {
  t=Date.now();
  try {
    if (strip === null) throw "empty json";
  }
  catch(err) {
    delete strip;  // local variable to the GC
    //errorDrawLights();
    console.log(err);
  }
  if (strip !== null) { 
  if ( numLights != strip.lc) {
      numLights = strip.lc;  
      pcm_resizeCanvas(false);
  }
  else if( prev_leds==strip.leds  && m==strip.m && mpi==strip.mpi) {
    mi=0; //millis since last frame
  } else {
    m=strip.m;  // effect mode index
    mpi=strip.mpi //multipartIndex
    mi=strip.mi; // millis since last frame
    prev_leds=strip.leds; //update previous strip state with actual state
    mpl=strip.leds.length; // multipart length 
    for (i = 0; i < mpl; i++) {
       renderLight(i+mpi*multipartSize, strip.leds[i],false);
    }
	 if (record) {	  
	  if (prev_mi==0) {
        prev_mi=mi;
      }
	  //console.log(prev_mi);
	  prev_mi=Math.floor(prev_mi/2);
      gif.addFrame(ctx, {copy: true, delay: prev_mi});
	  gifTimeRemaining -= prev_mi;
     prev_mi=mi
	  if (gifTimeRemaining<0  ) {
       record=false;
	   console.log("Gif rendering...");
       gif.render();    
      }
    } 
  }
  delete strip;  // local variable to the GC
  }  
  pcm_loadJSON(url,drawLights,errorDrawLights);  //request new  strip state
}

function getWindowSize(){
  windowWidth = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth)-30;
  windowHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
}

function windowResize(){
   getWindowSize();
   pcm_resizeCanvas(false);  
 }  

function pcm_setup() {
  canvas = document.getElementById("liveCanvas");  
  ctx = canvas.getContext("2d");
  window.onresize = windowResize;
  getWindowSize();
  pcm_resizeCanvas(false);
  pcm_loadJSON(url,drawLights,errorDrawLights); //get actual strip state
}

function postToState() {
var xmlhttp = new XMLHttpRequest();   // new HttpRequest instance 
xmlhttp.open("POST", host+"/json/state");
xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
xmlhttp.send(JSON.stringify({"seg":[{"fx": fx}]  }));
}


function cl() {
  gifTimeRemaining=gifDuration;
  prev_t=Date.now();
  gif = new GIF({
     workers: 8,
     workerScript: '/gif.js/gif.worker.js',
     quality: quality,
     width: canvas.width,
     height: canvas.height,
     debug:false
  });
  gif.on('finished', function(blob) {
     //var img = document.createElement("img");                 
     //img.src = URL.createObjectURL(blob);
     var a = document.createElement("a");
	 a.style.display = "none";
     a.href= URL.createObjectURL(blob);
     a.download="FX_"+m+".gif";
     document.body.appendChild(a);
     //a.appendChild(img);   
     a.click(); 
	 document.body.removeChild(a);
	 console.log("FX_"+m+".gif Generation Finished");
	 gif=null;
	 delete gif;
	 setTimeout(function(){delete blob;},2000);
	 fx++;	
	 if (fx<fxCount) {
		postToState();
		setTimeout(cl,10000);  //wait the canvas is renewed with new effect
	 } else {
	    window.location.reload();  //reload the page 
	 }
  }); 
  record=true; 
  console.log("GIF Generation Started")
}
fx=1;
postToState();
pcm_setup();
</script>
<br/><input type="button" value="Generate GIFs" onclick="cl()"><br/>
</body>
</html>
